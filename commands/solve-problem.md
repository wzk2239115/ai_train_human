---
description: 辅助你解决算法题，培养解题思维而不只是给答案
argument-hint: <题目描述/链接> [难度级别]
allowed-tools: [Read, Glob, Grep, Bash]
model: sonnet
---

# /solve-problem

让 AI 成为你的算法学习伙伴，而不是答案生成器。

## 使用方法

```
/solve-problem <题目描述或链接> [难度]
```

**示例：**
- `/solve-problem "两数之和"` - 经典哈希表题
- `/solve-problem "https://leetcode.cn/problems/longest-substring-without-repeating-characters/" medium` - 中等难度
- `/solve-problem "实现LRU缓存" hard` - 困难题目

## 这个命令的作用

与"给我解答"不同，这个命令会让 AI 帮助你：

1. **📖 带着读题** - 建立系统的读题思维习惯（复述、提取约束、想边界）
2. **💡 分析思路** - 引导你思考解决方案，而不是直接给代码
3. **🔍 识别模式** - 识别这是一类什么问题（DP、贪心、图论等）
4. **📊 讨论复杂度** - 分析时间和空间复杂度
5. **⚡ 优化方案** - 从暴力解到最优解的渐进优化
6. **🐛 调试错误** - 当你卡住时，帮助你找出问题

## 难度级别

- **easy**：基础数据结构，直白思路
- **medium** (默认)：需要一些技巧，多种解法
- **hard**：综合多个概念，边界情况复杂

## 读题思维框架

**这是最重要的第一步！** 很多错误源于没读懂题。

### AI 会带你一步步读题

```
你: /solve-problem "无重复字符的最长子串"

AI: 让我们一起仔细读这道题。

    ## 📖 读题第一步：提取核心信息

    请你用自己的话告诉我：
    1. 题目让你求什么？（目标）
    2. 输入是什么？
    3. 输出是什么？

    你: 找字符串中最长的、没有重复字符的子串，返回长度

    AI: 很好！让我们继续深挖...
```

### 读题检查清单

AI 会引导你回答这些问题：

#### 🎯 核心问题
- **目标是什么？** 找/求/计算/判断/返回？
- **输入是什么？** 类型、规模、格式
- **输出是什么？** 返回值、还是修改输入？

#### 📏 约束条件（关键！）
- **数据规模**：n ≤ ?（决定了能用 O(n²) 还是必须 O(n)）
- **空间限制**：O(1) 额外空间还是可以开数组？
- **时间要求**：1秒内能执行多少次操作？
- **特殊要求**：是否原地修改？是否需要稳定？

#### 🔍 边界情况
```
AI: 让我们想一些边界情况：
    - 输入为空会怎样？
    - 只有一个元素？
    - 全部相同？
    - 全部不同？
    - 负数、零、最大值？
```

#### 📋 示例理解
```
AI: 让我们看第一个示例：
    输入: "abcabcbb"
    输出: 3
    解释: "abc"

    你能手动模拟一遍这个过程吗？
    [让你自己走一遍，加深理解]
```

### 读题思维习惯

每次读题，AI 都会让你问自己：

| 问题 | 为什么重要 |
|------|-----------|
| **我读懂了吗？** | 能用自己的话复述 |
| **有没有隐藏信息？** | 约束条件往往是提示 |
| **数据范围是多少？** | 决定了算法复杂度上限 |
| **边界情况有哪些？** | 容易遗漏但容易出错 |
| **示例为什么是这样的？** | 示例往往包含关键信息 |

### 读题实战示例

```
你: /solve-problem "两数之和"

AI: 让我们仔细读这道题。

    ## 📖 第一步：你用自己的话说说这道题在做什么？

    你: 给一个数组和一个目标数，找两个数加起来等于目标，返回它们的索引

    AI: 很好！现在检查几个关键点：

    ## 📏 第二步：约束条件

    看到题目说：
    - 2 ≤ nums.length ≤ 10⁴
    - -10⁹ ≤ nums[i] ≤ 10⁹

    这告诉你什么？
    [引导你思考：n 可到 10000，O(n²) 会超时]

    你: 嗯，所以双重循环可能太慢了？

    AI: 对！这提示我们需要更快的解法。

    ## 🔍 第三步：边界情况

    想想这些情况：
    1. 答案存在吗？（题目说"可以假设只有一个答案"）
    2. 会用到同一个元素两次吗？（注意："不能使用相同元素"）
    3. 有负数怎么办？（约束里说了有负数）

    你：哦，所以不能用同一个元素两次...

    AI: 对！很多人写 `nums[i] * 2 == target` 就错了。

    ## 💡 第四步：从约束中找提示

    数据范围大 → 需要优于 O(n²) 的解法
    需要返回索引 → 不能排序（会打乱索引）
    快速查找 → 想到什么数据结构？

    你：哈希表！可以 O(1) 查找

    AI: 太好了！思路对了。现在我们开始想具体实现...
```

### 读题误区提醒

AI 会提醒你避免常见错误：

```
AI: ⚠️ 注意检查：
    - [ ] 题目要求返回值还是修改输入？
    - [ ] 是求"最大/最小"还是"任意一个"？
    - [ ] 是"子数组"还是"子序列"？
    - [ ] 索引从 0 还是 1 开始？
    - [ ] 需要排序吗？会破坏什么信息？
```

## 解题流程

```
## 1. 📖 读题（带着思维习惯）
- 用自己的话复述问题
- 提取约束条件和数据范围
- 从约束中推断算法复杂度要求
- 列出边界情况
- 手动模拟示例

## 2. 💡 思路引导
[AI引导你思考，而不是直接给答案]
- 你觉得可以用什么数据结构？
- 有没有类似的题目见过？
- 暴力解法是什么？

## 3. 🛠️ 实现方案
[在你理解思路后，讨论具体实现]
- 时间复杂度：O(?)，空间复杂度：O(?)
- 需要注意的细节

## 4. 💻 代码实现
[你自己实现，AI提供代码审查]
- 检查你的代码
- 指出潜在问题
- 建议优化方向

## 5. 🔄 复盘总结
- 这道题的核心是什么？
- 可以用什么模式/模板？
- 相关题目推荐
```

## 使用场景

### 场景1：刚看到题目，没有思路
```
你: /solve-problem "无重复字符的最长子串"
AI: 让我们一步步来分析这道题...

    1. 问题理解：你需要找到最长的子串，里面没有重复字符
    2. 举个例子："abcabcbb" → "abc" 长度 3

    你觉得可以用什么方法来记录字符是否重复？
    [引导你思考滑动窗口]
```

### 场景2：有思路但不确定对不对
```
你: /solve-problem "两数之和"
    我想到用双重循环，但感觉不是最优解
AI: 双重循环可以解决问题，O(n²)。但如果我告诉你可以在 O(n) 内解决，
    你有什么思路吗？

    提示：哈希表...
    [引导你优化到 O(n) 解法]
```

### 场景3：代码通过不了
```
你: /solve-problem "接雨水"
    我的代码过了一些用例，但其他的超时了
AI: 让我看看你的代码...

    问题在于：你重复计算了很多次
    优化思路：可以用双指针或预处理数组

    你想尝试哪种优化？
```

### 场景4：想学习多种解法
```
你: /solve-problem "爬楼梯" medium
AI: 这道题有多种解法！

    1. 递归（会超时，但好理解）
    2. 记忆化递归
    3. 动态规划
    4. 矩阵快速幂（进阶）

    你想先从哪个开始？
```

## 保存解题笔记

解决完题目后，可以保存到 Obsidian：

```
/save-learning "<题目名称> 题解" problem
```

**推荐笔记模板：**
```markdown
---
type: problem
date: {{date}}
platform: LeetCode/LintCode/其他
difficulty: Easy/Medium/Hard
tags: [problem, 数组, 双指针]
---

# {{题目名称}}

## 题目描述
[简洁描述]

## 核心思路
[解题思路，为什么这么做]

## 解法
[代码]

## 复杂度分析
- 时间：O(n)
- 空间：O(1)

## 关键点
- [关键点1]
- [关键点2]

## 易错点
- [容易出错的地方]

## 相关题目
- [[]]
- [[]]
```

## 算法模式识别

这个命令会帮你识别常见模式：

| 模式 | 典型题目 | 关键特征 |
|------|----------|----------|
| 滑动窗口 | 最长无重复子串 | 连续子数组/子串 |
| 双指针 | 两数之和 II | 有序数组 |
| 哈希表 | 两数之和 | 快速查找 |
| 单调栈 | 下一个更大元素 | 找最近更大/更小 |
| DFS/BFS | 岛屿数量 | 图/网格遍历 |
| 动态规划 | 爬楼梯 | 最优子结构 |
| 贪心 | 跳跃游戏 | 局部最优→全局最优 |
| 二分查找 | 搜索插入位置 | 有序数据 |

## 理念

> "授人以鱼不如授人以渔。"

这个命令不是关于快速AC——而是关于：
- ✅ 理解问题的本质
- ✅ 培养解题思维
- ✅ 学会识别模式
- ✅ 掌握优化方法
- ✅ 建立自己的知识体系

## 额外功能

### 生成测试用例
```
/solve-problem "两数之和"
你: 帮我设计几个边界测试用例
AI: 好的，以下是关键测试用例：
    1. 正常情况：[2,7,11,15], target=9
    2. 无解：[]
    3. 负数：[-3,4,2], target=1
    ...
```

### 分析相似题目
```
你: 这道题和之前做过的有什么类似？
AI: 这道题和 "三数之和" 思路类似：
    - 都用了排序 + 双指针
    - 都需要去重
    - 但这道题要求最接近，而不是等于
```

### 复杂度优化指导
```
你: 我的解法 O(n²) 能优化吗？
AI: 可以！观察到一个性质：[...]
    这样可以用二分查找优化到 O(n log n)
    或者用双指针优化到 O(n)
```
